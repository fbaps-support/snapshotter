#!/usr/bin/perl -w
#
# Manage snapshots according to a schedule.

use Time::Local;
use Getopt::Long;
use Symbol;
use Fcntl;
use Cwd;

# Find the per-filesystem snapshotter module based
# on the script name.
use FindBin;

# Get our fs-specific module.
die "Can't parse filesystem variant name out of '$FindBin::Script'\n"
    unless ($FindBin::Script =~ /^([a-z0-9]+)-snapshotter$/);

my $variant = $1;
require "$FindBin::RealBin/Snapshot/$variant.pm";

# Clear out the environment.
%ENV = ();
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:/usr/sbin";

my $test = 0;
GetOptions("test" => \$test);
die "Usage: $0 [-test] snapshot.conf [snapshot.conf ...]\n" unless (@ARGV >= 1);
my (@config) = @ARGV;

my $now = time;
my $lockfile = "/var/lock/snapshotter.lock";

my @t = localtime($now);
printf "--- Running at %04d-%02d-%02d %02d:%02d:%02d ---\n",
    1900+$t[5], 1+$t[4], $t[3], $t[2], $t[1], $t[0];

my $creations = 0;
my $deletions = 0;

# Can pass multiple configs on the command line and it'll
# run through them all. Read and validate all configs first.
my @configs = ();

# Remember where we started from - we need to run
# commands from the directory in which config files
# were located (so relative paths can be used), but
# this means we need to remember where to get back to.
my $cwd = Cwd::getcwd;
$cwd = $1 if ($cwd =~ /^(.*)$/); # Untaint it.

foreach my $configfile (@ARGV)
{
    # Parse the config.
    my $config = &readconfig($configfile);

    chdir($config->{dirname}) || die "chdir: $!\n";

    # If the source doesn't exist, it's an error
    # (unless okmissing is specified, in which case we skip).
    if (!Snapshot::exists($config->{source}))
    {
        next if ($config->{okmissing});

        die "Config source '$config->{source}' not found!\n";
    }

    # Get snapshot lists.
    $config->{snaps} = Snapshot::list($config);

    push(@configs, $config);

    chdir($cwd) || die "chdir: $!\n";
}

# Take a non-blocking lock. If we don't get it then exit.
sysopen(LOCK, $lockfile, Fcntl::O_RDWR|Fcntl::O_CREAT) || die "Can't open lock file $lockfile: $!\n";
flock(LOCK, Fcntl::LOCK_EX|Fcntl::LOCK_NB) || die "Another copy of $0 is running\n";

# Handle each config file.
foreach my $config (@configs)
{
    # Do we need to make a snapshot?
    my ($newsnap, $todelete) = &filtersnaplist($config);
    chdir($config->{dirname}) || die "chdir: $!\n";

    if (defined($newsnap))
    {
        my $doit = 1;

        # If there's a "test" option in the config file, run
        # the specified command and only take the snapshot if
        # that succeeds.
        if (defined($config->{test}))
        {
            my $ret = &runcommand($config->{test});
            $doit = ($ret == 0) ? 1 : 0;
        }
        if ($doit)
        {
            print "$config->{name}: Take snapshot $newsnap\n";
            &runcommand($config->{pre_snapshot}) 
                if (defined($config->{pre_snapshot}));

            $creations++;
            if (!$test)
            {
                if (Snapshot::snapshot($config, $newsnap))
                {
                    # Successful snapshot - add it to our list.
                    push(@{$config->{snaps}}, [ $newsnap, $now ]);
                }
                else
                {
                    warn "$config->{name}: Failed to create snapshot $newsnap\n";
                }
            }
            &runcommand($config->{post_snapshot})
                if (defined($config->{post_snapshot}));
        }
    }

    foreach my $delete (@{$todelete})
    {
        print "$config->{name}: Delete snapshot $delete\n";
        $deletions++;
        if (!$test)
        {
            if (!Snapshot::delete($config, $delete))
            {
                warn "$config->{name}: Error deleting snapshot $delete\n";
            }
        }
    }
}

# DO NOT close the lockfile before deleting - this would 
# lead to a race condition (I close, other instance opens
# and locks, then I delete).
unlink($lockfile);
close(LOCK);

printf "--- Completed %d creation%s and %d deletion%s in %ds ---\n", 
    $creations, $creations == 1 ? "" : "s",
    $deletions, $deletions == 1 ? "" : "s",
    time-$now;

sub readconfig
{
    my ($file) = @_;
    my $conffd = gensym;

    # Empty hash to fill out.
    my $config = {
        name => $file,
        snapshot => [],
        okmissing => 0,
    };

    $file = Cwd::abs_path($file);
    open($conffd, "<$file") || die "Can't read $file: $!\n";

    if ($file =~ m#^(.*)/([^/]*)$#)
    {
        $config->{dirname} = $1;
        $config->{basename} = $2;
    }
    else
    {
        die "Failed to parse '$file' for directory\n";
    }

    # Get a non-blocking lock. If we fail then exit as this
    # almost certainly means another run of the same script
    # is going and we'll end up with duplicates for any other
    # config in the list.
    if (!flock($conffd, Fcntl::LOCK_EX|Fcntl::LOCK_NB))
    {
        print "$config: in use\n";
        close($conffd);
        next;
    }

    while (<$conffd>)
    {
        s/#.*$//;
        s/^\s*//;
        s/\s*$//;
        next if ($_ eq "");

        # Parse out "tag = values" lines.
        my ($var, $values) = ($1, $2) if (/^(.*?)\s*=\s*(.*)\s*$/);
        die "$file: Unparseable at line $..\n" unless defined($var);

        # Check our tags and do the necessary.
        if ($var eq "source")
        {
            die "$file: source specified twice at line $..\n" 
                if (defined($config->{source}));
            $config->{source} = $values;
        }
        elsif ($var eq "dest")
        {
            die "Dest specified twice\n" if (defined($config->{dest}));
            $config->{dest} = $values;
        }
        elsif ($var eq "test")
        {
            die "test specified twice\n" if (defined($config->{test}));
            $config->{test} = $values;
        }
        elsif ($var eq "pre-snapshot")
        {
            die "pre-snapshot specified twice\n" 
                if (defined($config->{pre_snapshot}));
            $config->{pre_snapshot} = $values;
        }
        elsif ($var eq "post-snapshot")
        {
            die "post-snapshot specified twice\n" 
                if (defined($config->{post_snapshot}));
            $config->{post_snapshot} = $values;
        }
        elsif (($var eq "snapshot") || ($var eq "keep"))
        {
            my ($every, $maxage, $bias, $noreplicate) = (undef, undef, 0, 0);
            my $origvalues = $values;
            $every = &decodetime($1) if ($values =~ s/^\s*every\s+(\S+)//);
            $maxage = &decodetime($1) if ($values =~ s/^\s*for\s+(\S+)//);
            $bias = &decodetime($1) if ($values =~ s/^\s*bias\s+(\S+)//);

            die "$file: snapshot rule incorrectly specified at line $. (unparsed = '$values').\n"
                unless (defined($every) && defined($maxage) && ($values eq ""));

            die "$file: snapshot rule at $. specifies \"every\" greater than \"for\"\n"
                if ($every > $maxage);

            die "$file: snapshot rule at $. specifies \"bias\" greater than \"every\"\n"
                if ($bias > $every);

            push(@{$config->{snapshot}}, {
                spec => $origvalues,
                maxslot => int($maxage/$every),
                bias => $bias,
                res => $every,
            });
        }
        elsif ($var eq "okmissing")
        {
            die "$file: okmissing must be true or false\n"
                unless ($values =~ /^(true|false)$/);
            $config->{okmissing} = ($values eq "true");
        }
        else
        {
            die "$file: Unknown setting at line $.: $_\n";
        }
    }

    die "$file: Contains no source directory\n"
        unless (defined($config->{source}));

    die "$file: Contains no snapshot rules\n"
        if (@{$config->{snapshot}} == 0);

    # Sort them into increasing resolution order.
    @{$config->{snapshot}} = sort { $a->{res} <=> $b->{res} } @{$config->{snapshot}};

    return $config;
}

# Decode a "friendly" time into seconds.
sub decodetime
{
    my ($period, $line) = @_;
    my %multiply = (
        sec => 1,
        min => 60,
        hour => 3600,
        day => 86400,
        week => 604800,
        year => 31536000
    );

    die "Invalid period '$period' specified in line $.\n" 
        unless ($period =~ /^(\d+)(sec|min|hour|day|week|year)s?$/);
    return $1*$multiply{$2};
}

sub filtersnaplist
{
    my ($config) = @_;
    
    my @delete = ();
    my %keep = ();
    my $newsnap = undef;

    foreach my $rule (@{$config->{snapshot}})
    {
        my %seen = ();
        my $nowslotstart = $now - (($now - $rule->{bias}) % $rule->{res});

        foreach my $snap (@{$config->{snaps}})
        {
            my ($ent, $stamp) = @{$snap};

            my $stampslotstart = $stamp - (($stamp -$rule->{bias}) % $rule->{res});

            my $slot = int(($nowslotstart-$stampslotstart)/$rule->{res});
            $slot = 0 if ($slot < 0);
            if (!defined($seen{$slot}) && ($slot <= $rule->{maxslot}))
            {
                $keep{$ent} = 1;
                $seen{$slot} = $ent;
            }
        }
        $newsnap = Snapshot::newname($config) unless defined($seen{0});
    }

    # Finally work out what needs deleting after processing all rules.
    my @keep = ();
    foreach my $snap (@{$config->{snaps}})
    {
        if (!defined($keep{$snap->[0]}))
        {
            push(@delete, $snap->[0]);
        }
    }

    return ($newsnap, \@delete);
}

sub runcommand
{
    my ($cmd) = @_;
    if ($test)
    {
        print "Would run '$cmd'\n";
        return 0;
    }
    else
    {
        system "/bin/bash", "-c", $cmd;
        return $? ? 1 : 0;
    }
}


__END__

=head1 NAME

snapshotter - Take and retain snapshots according to a schedule.

=head1 SYNOPSYS

  snapshotter [-test] configfile [configfile ...]

=head1 DESCRIPTION

This script will maintain a collection of dated snapshots for a filesystem.
The snapshots will be retained according to a set of rules in a configuration file. 

Each configuration file describes how to manage snapshots of a single
location. Multiple configuration files can be specified on the command line.

If the B<-test> option is supplied then the script will describe what actions it
would take, but won't actually do take them.

=head1 CONFIGURATION

The configuration file contains a set of B<tag = value> specifications. Blank lines
are ignored, as is anything after a B<#> on any line.

=head2 Configuration Directives

=over

=item B<source = >location

This specifies which location to manage. Dated snapshots
of this location will be created. This directive is compulsory.

=item B<dest = >location

This optional directive specifies where the snapshots should be 
created.

=item B<test = >command

If B<test> is specified then it is run before a snapshot is 
taken. If the command returns non-zero then the snapshot is not
taken. You could use this to e.g. ping a host to see whether it
is up.

=item B<pre-snapshot = >command

If B<pre-snapshot> is specified it is run before a snapshot is
taken. The snapshot will be taken irrespective of the command's
return code. You could use this to e.g. rsync some data from a 
host before taking the snapshot.

=item B<post-snapshot = >command

If B<post-snapshot> is specified it is run after a snapshot is
taken.

=item B<snapshot = every> timeperiod B<for> timeperiod [B<bias> timeperiod]

Specifies how often snapshots should be created and how long they should be kept 
The optional "bias" value specifies whether an offset to the slot start
should be used. This allows daily snapshots, for example, to be specified as
taking place at 3am (using bias 3hours). Multiple B<snapshot> directives
may be specified to construct a complex retention policy. For example:

  snapshot = every 1min for 1hour
  snapshot = every 30mins for 1day
  snapshot = every 1day for 1week
  snapshot = every 1week for 1year
  snapshot = every 26weeks for 10years

=back

=head2 Time periods

Time periods are specified as a number immediately followed by a period
specifier, optionally followed by "s" (for readability). The period specifiers
are: sec, min, hour, day, week, year.

=head1 NOTES

=over

=item You should run B<snapshotter> from cron at least as
frequently as the shortest time period specified in any of its configuration 
files.

=back

=head1 AUTHOR

Alun Jones <auj@aber.ac.uk>

=cut


